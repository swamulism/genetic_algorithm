import GAinspector
# import numpy as np
from utils import *

def randomGenome(length):
    """
    :param length:
    :return: string, random binary digit
    """
    return "".join(map(str,  [random.randint(0,1) for i in range(length)])) 


def makePopulation(size, length):
    """
    :param size - of population:
    :param length - of genome:
    :return: list of length size containing genomes of length length
    """
    return [randomGenome(length) for _ in range(size)]


def fitness(genome):
    """
    :param genome: 
    :return: the fitness value of a genome
    """
    return sum(list(map(int, genome)))


def evaluateFitness(population):
    """
    :param population: 
    :return: a pair of values: the average fitness of the population as a whole and the fitness of the 
    best individual in the population.
    """
    fitnesses = [fitness(x) for x in population]
    return (Average(fitnesses), max(fitnesses))


def crossover(genome1, genome2):
    """
    :param genome1:
    :param genome2:
    :return: two new genomes produced by crossing over the given genomes at a random crossover point.
    """
    split = random.randint(1, len(genome1) - 1)
    child1 = genome1[:split] + genome2[split:]
    child2 = genome2[:split] + genome1[split:]
    return (child1, child2)


def mutate(genome, mutationRate):
    """
    :param genome:
    :param mutationRate:
    :return: a new mutated version of the given genome.
    """
    tmp = ""
    for chrom in genome:
        if random.random() <= mutationRate:
            if chrom == "0":
                tmp += "1"
            else:
                tmp += "0"
        else:
            tmp += chrom
    return tmp


def selectPair(population):
    """
    :param population:
    :return: two genomes from the given population using fitness-proportionate selection. 
    This function should use weightedChoice, which we wrote in class, as a helper function.
    """
    pop_fitness = [fitness(x) for x in population]
    individual1 = weightedChoice(population, pop_fitness)
    individual2 = weightedChoice(population, pop_fitness)
    return (individual1, individual2)


def runGA(populationSize, crossoverRate, mutationRate, logFile=""):
    """
    :param populationSize: 
    :param crossoverRate: 
    :param mutationRate: 
    :param logFile - The optional logFile parameter is a string specifying the name of a text 
    file in which to store the data generated by the GA, for plotting purposes.:
    :return: When the GA terminates, this function should return the generation at which the string of all 
    ones was found.is the main GA program, which takes the population size, crossover rate (pc), 
    and mutation rate (pm) as parameters. 
    """
    genome_length = 20
    generations = 50
    population = makePopulation(populationSize, genome_length)

    for i in range(generations):
        gnome1, gnome2 = selectPair(population)
        avg_fitness, highest_fitness = evaluateFitness(population)
        for j in range(population):
            if random.random() <= crossoverRate:
                new_pop += crossover(genome1, gnome2):
            else:
                new_pop += genome1, genome2


    raiseNotDefined()


if __name__ == '__main__':
    # Testing Code
    # print("Test Suite")
    # GAinspector.test(randomGenome)
    # GAinspector.test(makePopulation)
    # GAinspector.test(fitness)
    # GAinspector.test(evaluateFitness)
    # GAinspector.test(crossover)
    # GAinspector.test(mutate)
    # GAinspector.test(selectPair)
    runGA(100, 0.7, 0.001, "run1.txt")
